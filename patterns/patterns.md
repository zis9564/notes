### паттерн проектирования
понятие инженерии програмного обеспечения, 
описывающее часто применяемые решения для распространенных проблем проектирования ПО

---

#### отличитрельные признаки:
- относится к конкретному к конкретному сценарию а не платформе. его контекстом являются окружающие условия в которых существует проблема
- разработаны для поиска оптимального решения определенных задач, возникающих при создании программного обеспечения.
- представляют собой решение только тех проблем, для которых пред- назначены.

---

#### порождающие паттерны: 
позволяют конструировать объекты, когда одних конструкторов недостаточно. 
Логика создания объектов скрывается. Программы, в основе которых лежат эти паттерны, обеспечивают больше гибкости
при создании объектов в соответствии с вашими нуждами и сценариями использования приложения.

#### структурные паттерны:
имеют дело с композицией классов или объектов. Существует две основные методики повторного использования функциональности в ООП: 
наследование классов и композиция объектов. Наследования применяется для композиции интерфейсов 
и определения способов композиции объектов в целях создания новой функциональности.

#### поведенческие паттерны:
касаются способов взаимодействия и распределения обязанностей между классами или объектами. 
Особенно тесно связаны с обменом информацией между объектами. 
Служат для контроля сложных потоков данных в приложениях.

---

### [Factory](Factory.java)
#### Порождающий паттерн

![factory.png not found](img/factory.png)

Согласно этому паттерну, для получения объекта класса можно не раскрывать клиенту нижележащую логику. 
Новый объект назначается вызывающей стороне с помощью общего интерфейса или абстрактного класса.\
Это значит, что данный паттерн скрывает:
- фактическую логику реализации объекта 
- способ его создания 
- какой класс он воплощает.

В результате клиента не будет заботить создание объекта, управление и уничтожение Factory возьмет на себя

используется для решения следующих проблем:
- избавляет разработчика от бремени создания объектов и управления ими.
- избавляет от тесного сцепления между взаимодействующими компонентами, тк компонент не может заранее знать, какие подклассы ему понадобится создать
- избавляет от жестко зашитого кода создания объекта класса.

---

### [Abstract Factory](AbstractFactory.java)
#### Порождающий паттерн

![abstract-factory.png not found](img/abstract-factory.png).

Обеспечивает интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов без указания конкретных классов.
Паттерн более высокого уровня, чем Factory. Согласно ему необходимо просто описать интерфейс или абстрактный класс 
для создания взаимосвязанных или взаимозависимых объектов без указания конкретных классов.

набор фабричных методов, объединенный в фабрику с помощью паттерна проектирования «Factory», получаем фабрику фабрик. 
таким образом нам больше не требуется знать подробности обо всех фабриках в этой фабрике. 
для написания программы достаточно информации о фабрике верхнего уровня.

Преимущества паттерна AbstractFactory:
- слабое сцепление между семействами компонентов. 
- изоляция кода клиента от конкретных классов.
- обеспечивает лучшую согласованность в масштабах приложения во время конструирования объектов.
- обеспечивает легкость замены семейств компонентов.

При проектировании паттерна Factory для создания объектов в приложении бывает необходимо скомпоновать определенный набор
взаимосвязанных объектов с конкретными ограничениями и использовать в них нужную логику. 
Для этого можно создать внутри фабрики еще одну фабрику для набора взаимосвязанных объектов и наложить на них требуемые ограничения, 
а затем написать логику для данного набора.
можно использовать, если требуется адаптировать логику создания объектов к конкретной задаче.

---

### [Prototype](Prototype.java)
#### Порождающий паттерн

![prototype.png not found](img/prototype.png)

Используется для создания объектов путем клонирования на основе экземпляра-прототипа. 
Когда создание объекта и инициализации начальных значений требует значительных затрат ресурсов. Имеет смысл воспользоваться Prototype. 
Например, когда объект создается после операции с базой данных. Объект можно кэшировать, вернуть его клон при следующем запросе 
и обновлять базу по мере необходимости, уменьшая таким образом количество требуемых обращений к ней. 
При этом просто копируется уже существующий подобный объект вместо создания нового.
Этот паттерн включает реализацию прототипного интерфейса в целях создания клона существующего объекта.

Преимущества паттерна Prototype:
- уменьшает время, необходимое для создания объектов.
- сокращает создание производных классов. 
- добавляет и удаляет объекты во время выполнения. 
- динамически задает настройки классов приложения.

---

### [Builder](Builder.java)
#### Порождающий паттерн

![builder.png not found](img/builder.png)

Позволяет создавать сложные объекты пошагово и использовать один и тот же код для создания различных представлений объектов.

Преимущества паттерна Builder:
- полная изоляция процесса конструирования объекта от его представления. 
- возможность конструирования объекта в несколько этапов, что позволяет получить больше контроля над процессом конструирования.
- широкие возможности варьирования внутреннего представления объекта.

Builder имеет смысл использовать, если процесс создания объекта состоит из нескольких шагов. 
На каждом из шагов выполняется часть процесса. 
В ходе создания объекта задаются необходимые и необязательные параметры, и в результате получается сложный объект.

---

### [Adapter](Adapter.java)
#### Структурный паттерн

![adapter.png not found](img/adapter.png)

Adapter служит мостом между двумя несовместимыми интерфейсами и используется, когда два интерфейса приложения функционально несовместимы, 
но их нужно объединить из-за бизнес-требования.

Преимущества паттерна Adapter:
- возможность взаимодействия между двумя или более несовместимыми объектами. 
- способствует повторному использованию уже существующих более старых элементов функциональности.

используется для решения следующих проблем:
- нужно воспользоваться существующим классом, интерфейс которого несо- вместим с вашими нуждами.
- нужно создать в своем приложении повторно используемый класс который должен взаимодействовать с классами с несовместимыми интерфейсами.
- использовать несколько существующих подклассов, но адаптировать их интерфейсы но создавать производные подклассы от каждого из них нецелесообразно. Лучше применить адаптер объектов для подгонки интерфейса родительского класса.

---

### [Bridge](Bridge.java)
#### Структурный паттерн

![bridge.png not found](img/bridge.png)

Bridge предоставляет способ добиться взаимодействия между двумя различными независимыми компонентами, 
а также способ расцепления абстрактного класса и класса-реализатора. Поэтому любые изменения в классе реализации или реализаторе(интерфейсе) 
не повлияют ни на абстрактный класс, ни на класс расширенной абстракции. 
Это становится возможным благодаря композиции интерфейса и абстракции.

Преимущества паттерна Bridge:
- позволяет разделить реализацию и абстракцию.
- обеспечивает достаточную гибкость внесения изменений в классы обоих типов без какого-либо влияния на клиентский код.
- позволяет скрывать нюансы фактической реализации от клиента за счет наличия между ними абстракции.

используется для решения следующих проблем:
- если нужно устранить стойкую привязку функциональной абстракции к ее реализации.
- если нужно вносить изменения в классы реализации без какого-либо влияния на абстракцию и клиентский код.
- если нужно дать возможность расширять абстракцию и ее реализацию с помощью подклассов.

---

### [Composite](Composite.java)
#### Структурный паттерн

![composite.png not found](img/composite.png)

Объекты можно объединять в древовидные структуры, отражающие иерархии типа часть—целое. 
Благодаря составному объекту клиенты могут работать одинаковым образом как с отдельными объектами, так и с их композициями.

суть Composite в том, что клиент взаимодействует с группой объектов одного типа как с единым объектом. 
Идея паттерна Composite состоит в композиции набора объектов в древовидную структуру, которая бы представляла модуль большего приложения. 
А клиенты рассматривают эту структуру как единое целое. 
Объекты в системе группируются в древовидную структуру, представляющую собой сочетание узлов-листьев и веток. 
В ней узлы могут иметь листья и другие узлы, а у листьев нет никаких дочерних элементов. 
Листья рассматриваются как конечные точки структурированных в дерево данных.

Преимущества паттерна Composite:
- облегчает добавление новых видов компонентов, избавляя от необходимости вносить в клиент изменения.
- позволяет создавать иерархию классов, включающую как отдельные, так и составные объекты.

---

### [Decorator](Decoratior.java)
#### Структурный паттерн

![decorator.png not found](img/decorator.png)

Decorator представляет особую разновидность структурного паттерна проектирования и позволяет динамически/статически добавлять 
и исключать поведение отдельных объектов, не изменяя имеющееся поведение других связанных объектов того же класса. 
При этом не нарушаются принципы SOLID

Для задания ассоциаций объектов оказывается предпочтение композиции вместо наследования, дает возможность разделять функциональность
на различные классы с непересекающимися областями ответственности.

Преимущества паттерна:
- позволяет динамически и статически расширять функциональность, не меняя структуры существующих объектов.
- с помощью этого паттерна можно динамически назначить объекту новую обязанность.
- чтобы обеспечить соблюдение принципов SOLID, он использует композиции взаимосвязей объектов.
- упрощает написание кода благодаря созданию новых классов для каждого элемента функциональности вместо изменения существующего кода приложения.

используется для решения следующих проблем:

---

### [Combinator](Combintor.java)
Комбинатор хорошо известен в функциональном программировании. Идея состоит в том, чтобы объединить примитивы в более сложные структуры.
Хороший пример использования этого паттерна - валидация.

### [Observer](Observer.java)
поведенческий паттерн. Создает механизм подписки позволяющий одним объектам следить и реагировать на события
    происходящие в других объектах. Предлагает хранить внутри объекта издателя список ссылок на объекты подписчиков, 
    причём издатель не должен вести список подписки самостоятельно. 
    Он предоставит методы, с помощью которых подписчики могли бы добавлять или убирать себя из списка.

### [Visitor](Visitor.java)
поведенческий паттерн. позволяет добавлять в программу новые операции не изменяя классы объектов над которыми эти операции будут проводиться.

---

### []()
#### Структурный паттерн

![]()

Преимущества паттерна :

используется для решения следующих проблем:

---