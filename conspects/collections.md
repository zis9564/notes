
**Коллекция** - это структура данных, набор однотипных объектов.

**Java collection frmework** в своей основе содержит 2 интерфеса:

- [Collection](#collection-interface) - для простых последовательных наборы элементов
- [Map](#map-interface) - для пар ключ-значение.

#### **COLLECTION INTERFACE:**

- List\
 [ArrayList](#arraylist)\
 [LinkedList](#linkedlist)\
 [Vector](#vector)\
 [Stack (LIFO)](#stack)
- Set\
 [HashSet](#hashset)\
 [LinkedHashSet](#linkedhashset)\
 [TreeSet](#treeset)
- Queue (FIFO)\
 [PriorityQueue](#priorityqueue)\
 [ArrayDeque](#arraydeque)


###### ArrayList
    ArrayList - Коллекция разрешает хранить дубликаты. В основе коллекции лежит массив, 
    а значит требует непрерывного диапазона ячеек памяти. Динамически изменяет размер. 
    Имеет константное время доступа к любой ячейки массива.

###### LinkedList
    LinkedList - коллекция разрешает хранить дубликаты. Двунаправленный связный список.
    Имплементирует интерфейсы List и Deque 
    Каждый элемент LinkedList хранит не только информацию, но и ссылку на след и пред элементы.
    Имеет линейное время O(n) доступа к любой ячейки массива. 
    Следует использовать когда нужно добавлять и удалять значения в любом месте массива.

###### Vector
    Vector - старая имплементация List syncronized, но не является полностью потокобезопасным 
    (синхронизирует операции, но не полностью экземпляр) и имеет deprecated методы.

###### Stack
    Stack - реализует стандартный стек last-in first-out. наследуется от класса Vector

###### HashSet 
    HashSet - не поддерживает дубликатов (дубликат не будет добавлен) 
    Не поддерживает удаление по индексу, не гарантируется порядок элементов при добавлении. 
    Под капотом использует HashMap для хранения данных. 
    В качестве ключа и значения используется добавляемый элемент. 
    Позволяет добавлять, удалять и искать элементы за O(1).

###### LinkedHashSet
    LinkedHashSet - гарантирует порядок элементов по порядку их добавления. 
    Вставка, удаление, и поиск элементов происходит за O(1) в худшем случае O(n)

###### TreeSet
    TreeSet - есть возможность управлять порядком элементов при помощи Comparator. 
    По умолчанию сохраняет элементы с использованием «natural ordering». 
    Позволяет добавлять, удалять и искать элементы за O(logN).

###### PriorityQueue
    PriorityQueue - реализует принцип first in first out. 
    Не поддерживает NULL, не поддержиает элементы не имплементирующие интерфейс Comparable
    Не является потокобезопасным.
    используется, когда нужно обрабатывать элементы в зависимости от их приоритетности,
    сохраняет элементы с использованием «natural ordering» или custom компаратора 
    главой является наименьший элемент по отношению к указанному порядку. 
    Если несколько элементов привязаны к наименьшему значению, голова является произвольным элементом. 
    Скорость чтения и записи O(log(n)).
    PriorityBlockingQueue - потокобезопасный вариант PriorityQueue.

###### ArrayDeque
    ArrayDeque - динамически resizable массив, позволяющий добавлять и удалять элементы с обоих концов. 
    Не поддерживает NULL, не является потокобезопасным. 
    Имплементирует интерфейсы Queue и Dequeue. 
    Быстрее чем Stack когда используется как Stack, 
    Быстрее чем LinkedList когда используется как Queue

#### **MAP INTERFACE:**

 [HashTable](#hashtable)\
 [HashMap](#hashmap)\
 [LinkedHashMap](#linkedhashmap)\
 [TreeMap](#treemap)\
 [WeakHashMap](#weakhashmap)

###### HashTable
    HashTable - потокобезопасна не поддерживает NULL в качестве ключа и значения. является deprecated

###### HashMap
    HashMap - не является потокобезопасной поддерживает NULL в качестве ключа и в качестве значения.

###### LinkedHashMap 
    LinkedHashMap - наследуется от HashMap не является потокобезопасной поддерживает порядок добавления элементов

###### TreeMap
    TreeMap - поддерживает сортировку по компаратору или натуральный порядок не является потокобезопасной. 
    Не поддерживает NULL в качестве ключа

###### WeakHashMap
    WeakHashMap - тоже самое что HashMap но с одним отличием. 
    Если ключ не содержит значений, сборщик мусора может удалить ключ. 
    Сборщик мусора доминирует над WeakHashMap