
**Концепция Spring:**\
Основной концепт - это инверсия контроля.\
Вместо того чтобы самим создавать экземпляры классов и управлять их завиимостями, Spring берет эту работу на себя.\
Spring реализует инверсию контроля используя **dependency injection**.\
Spring IoC Container (**Context**) - контекст хранит конигурацию нашего приложения и бины.\
Конфигурация спринга может быть реализована помощью **XML** или **Annotation**\
Spring оперирует бинами.

---

**Аннотации Spring:**\
**@Component** - для любого компонента фреймворка.\
**@Service** - класс представляет собой компонент сервис-слоя. Позволяет искать бины-сервисы автоматически.\
**@Repository** - класс функционирует как репозиторий.\
**@Controller** - класс контроллер. представляет собой компонент, работающий с **HttpServletRequest** и **HttpServletResponse**\
**@ResponseBody** - метод может возвращать кастомный объект в виде xml, json...\
**@RestController** - аккумулирует поведение двух аннотаций **@Controller** и **@ResponseBody**\
**@Transactional** - перед исполнением метода начинается транзакция, после выполнения транзакция коммитится, при Exception откатывается.\
**@Autowired** - позволяет автоматически установить значение поля.\
**@RequestMapping** - используется для маппинга url запроса на указанный метод или класс.\
**@PathVariable** - показывает, что параметр метода должен быть связан с переменной из url.\
**@Scope** - установка области жизни бина\
**@PostConstruct** - метод будет вызван после вызова конструктора бина.\
**@PreDestroy** - метод будет вызван перед уничтожением бина.\
**@Profile** - создание профилей конфигурации проекта. Может применяться как к бинам так и к конфигурационным классам.

---

**Скоуп бинов:**\
**SINGLETON** - определяет только один бин для каждого контейнера спринг\
**PROTOTYPE** - позволяет именть любое кол-во экземпляров бина\
**REQUEST** - создается по одному бину на каждый http запрос\
**SESSION** - создается по одному бину на каждую http сессию\
**GLOBAL_SESSION** - создается по одному бину на каждую глобальную http сессию используется для Portlet приложений.

---

**TRANSACTION:**\
это последовательность операций над данными имеющая начало и конец. Транзакция должна соответствовать требованиям ACID.\
**Atomicity** - выполнена полностью или не выполнена совсем\
**Consistency** - фиксирует результаты сохраняя консистентность бд\
**Isolation** - параллельные транзакции не должны оказывать влияние друг на друга\
**Durability** - после завершения транзакции данные не могут быть отменены (исчезнуть)

**Transactions models:**\
**LOCAL** - JDBC\
**PROGRAMMATIC** - JPA\
**DECLARATIVE** - Spring

---

**Propagation:**\
**REQUIRED** - если нет активной транзакции, спринг создаст новую, если уже есть - присоединится к текущей трансакции\
**SUPPORT** - если нет активной трансакции, спринг выполнит действие вне транзакции, если есть - присоединится\
**MANDATORY** - если нет активной трансакции, спринг бросит исключение, если есть - присоединится\
**NEVER** - если нет транзакции, выполнится без транзакции, если есть - бросит исключение\
**NOT_SUPPORTED** - если есть транзакция, спринг ее остановит, а потом выполнит вне транзакции\
**REQUIRES_NEW** - если есть трансакция, спринг ее остановит, а потом откроит новую и выполнит код в ней.\
**NESTED** - если транзакция есть, создает сейв-поинт, если нет работает как required

---

**Transaction problem:**\
**DIRTY_READ** - чтение данных, добавленных или изменённых транзакцией, которая впоследствии откатится.\
**NON_REPEATABLE READ** - при повторном чтении в рамках 1 транзакции ранее прочитанные данные оказываются изменёнными.\
**PHANTOM_READ** - при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк.

---

**Transaction isolation level:**\
**READ_UNCOMMITTED** - (нет защиты) другие транзакции **могут** читать не закоммиченные данные, измененные текущей транзакцией.\
**READ_COMMITTED** - (защита от **DIRTY READ**) другие транзакции **не могут** читать не закоммиченные данные, измененные текущей транзакцией.\
**REPEATABLE_READ** - (защита от **NON REPEATABLE READ**) **Read committed** + другие транзакции **НЕ могут** изменять данные читаемые текущей транзакцией до ее завершения.\
**SERIALIZABLE** - (защита от **PHANTOM READ**) **Repeatable read** + другие транзакции **НЕ могут** вставлять новые данные со значениями ключа которые входят в диапазон ключей для считываемых инструкциями текущей транзакции до ее завершения.

---

**Hibernate**\
ORM фремворк предназначен для решения задач объектно-реляционного отображения, самая популярная реализация спецификации JPA

**Интерфейсы Hibernate:**

**SessionFactory** неизменяемый потокобезопасный объект с компилированным маппингом для одной базы данных.\
Необходимо инициализировать **SessionFactory** всего один раз. Используется для получения объектов **Session**, которые используются для операций с базами данных.

**Session** однопоточный короткоживущий объект, который предоставляет связь между объектами приложения и базой данных.\
оборачивает **JDBC Connection** и работает как фабрика для **Transaction**.\
Разработчик должен открывать сессию по необходимости и закрывать ее сразу после использования.\
Экземпляр **Session** является интерфейсом между кодом в **java** приложении и **hibernate** и предоставляет методы для операций **CRUD**.

**Transaction** однопоточный короткоживущий объект, используемый для атомарных операций.

---

**Аннотации Hibernate:**\
**@Entity** - используется для указания класса как **entity bean**.\
**@Table** -  используется для определения имени таблицы из БД, которая будет отображаться на **entity bean**.\
**@Id** - определяет primary key в **entity bean**.\
**@EmbeddedId** - используется для определения составного ключа в бине.\
**@Embedable** - (field annotation) для отображения **композиции** в общую таблицу.\
**@Embeded** - (class annotation) для отображения **композиции** в общую таблицу.\
**@Column** - определяет имя колонки из таблицы в базе данных.\
**@GeneratedValue** - задает стратегию создания primary key.
- **AUTO** - (default) на основе типа поля в **id** будет генерировать **Numeric** или **UUID** значения\
- **IDENTITY** - полагается на **IdentityGenerator** в бд колонка **identity** (автоинкрементирует)\
- **SEQUENCE** - (recommended) полагается на **SequenceStyleGenerator** генерирует инкрементные integers при каждом последующем запросе.\
- **TABLE** - hibernate эмулирует **sequence** через дополнительную таблицу.\
**@MappedSuperclass** - используется когда мы хотим спрятать общие поля для нескольких entity. Cам аннотированный класс не рассматривается как отдельная сущность.\
**@OneToOne** - задает связь один-к-одному между двумя сущностными бинами.\
**@Cascade** - определяет каскадную связь между двумя **entity бинами**.

---

**Cостояния entity bean:**
- **Transient** - объект никогда не был связан с сессией и не является persistent.\
Объект в этом состоянии может стать **persistent** при вызове метода **save(), persist()** или **saveOrUpdate()**.\
Объект **persistent** может перейти в **transient** состоянии после вызова метода **delete()**.
- **Persistent** - persisted сущность всегда имеет id. persistent объект связан с уникальной сессией. Любой экземпляр, возвращаемый методами **get()** или **load()** находится в состоянии **persistent**.
- **Detached** - объект был персистентным, но сейчас не связан с какой-либо сессией, то он находится detached состоянии.\
такой объект можно сделать персистентным используя методы **update(), saveOrUpdate(), lock()** или **replicate()**.\
Состояния **transient** или **detached** так же могут перейти в состояние **persistent** как новый объект персистентности после вызова метода **merge()**.

---

**Методы Hibernate:**
- **save()** используется для сохранения сущности в базу данных. Может быть вызван без транзакции. Немедленно возвращает сгенерированный идентификатор.
- **persist()** аналогичен save() с транзакцией. Возвращает сгенерированный идентификатор после TR.commit.
- **saveOrUpdate()** использует запрос для вставки или обновления. Если данные уже есть в бд, то будет обновление. Может быть вызван без транзакции.
- **flush()** смывает накопившиеся **inserts, updates** и **deletes** в бд. По-умолчанию **flush** выполняется в случаях:
  - Перед выполнением query (чтобы соблюсти принцип ACID)\ 
  - При коммите транзакции\
  - При persist новой сущности - в случае когда мы можем получить ее **id** только через **insert**.

---

**Collection Hibernate:**\
коллекции используются для представления связи one-to-many.
- **Set** - неупорядоченное множество сущностей без повторений.
- **Bag** - неупорядоченное множество сущностей. java нет такой структуры => любой list без указания колонки сортирования = bug.
- **List** - упорядоченное множество сущностей.

---

**Criteria API:**
используется для выборки из базы данных в более объектно-ориентированном стиле.

---

**N+1 проблема**\
это ситуация, когда вместо одного запроса на выбор **N** книг происходит по меньшей мере **N+1** запрос.\
способ решения **N+1** проблемы это сделать **fetch** связанных таблиц. однако у нас может возникнуть несколько других проблем:\
- Пагинация в случае отношений **OneToMany hibernate** не сможет указать **offset** и **limit**. Поэтому пагинация будет происходить **in-memory**.\
- Проблема декартова произведения - это ситуация, когда на выбор **N** книг с **M** главами и **K** авторами бд возвращает N * M * K строк.