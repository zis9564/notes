equals() для подтверждения или отрицания что 2 объекта одного класса являются логически равными. по умолчанию сравнивает ссылки на объект в памяти.

не стоит переопределять equals():
- когда каждый экземпляр класса является уникальным (например если класс представляет опр. поведение) <Thread.class>
- когда у класса нет необходимости определять эквивалентность его экземпляров <Random>
- когда класс имеет предка, и поведение equals у предка нас устраивает <Set, List, Map> (реализация equals() уже определена в Abstract версиях классов)
- когда область видимости класса private или package и мы уверены, что этот метод не будет вызван

КОНТРАКТ EQUALS():
- РЕФЛЕКСИВНОСТЬ для любого x (x != null) x.equals(x) должно быть true
- СИММЕТРИЧНОСТЬ для любых x,y x.equals(y) == true только в том случае что y.equals(x) == true
- ТРАНЗИТИВНОСТЬ для любых x,y,z x.equals(y) и y.equals(z) == true x.equals(z) должно быть true
- СОГЛАСОВАННОСТЬ для любых x,y повторный вызов x.equals(y) вернет то-же значение,если нет изм.
- СРАВНЕНИЕ NULL для любого x x.equals(null) должен возвращать false.

- РЕФЛЕКСИВНОСТЬ объект должен быть равен самому себе
- СИММЕТРИЧНОСТЬ объекты равны не смотря на порядок сравнения x=y | y=x
- ТРАНЗИТИВНОСТЬ если (x=y && y=z) -> x=z
- СОГЛАСОВАННОСТЬ повторный вызов equals() вернет то-же значение, если нет изм.

HASH — это целое число, генерируемое на основе объекта и описывающее состояние в момент времени исп в основном в хеш-талицах

КОНТРАКТ HASHCODE:
- вызов hashcode() 1+ раз над одним объектом должен возвращать одно и то-же значение
- вызов hashcode() над 2+ объектами должен возвращать одно значение если объекты equals()=true
- вызов hashcode() над 2 разными объектами должен возвращать разное значение

hashCode() нет, equals() есть ->
	то с точки зрения equals() объекты равны, но с точки зрения hashCode() они не будут иметь ничего общего. значит что мы рискуем не получить объект обратно из hash таблицы
hashCode() есть, equals() нет ->
	 hashCode() будет возвращать одинаковые значения для одинаковых объектов, но для поиска объекта в хэш-таблице помимо сравнения хэш-значений ключа используется равенства ключа с искомым объектом