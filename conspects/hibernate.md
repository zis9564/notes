
**TRANSACTION:**\
это последовательность операций над данными имеющая начало и конец. Транзакция должна соответствовать требованиям ACID.\
**Atomicity** - выполнена полностью или не выполнена совсем\
**Consistency** - фиксирует результаты сохраняя консистентность бд\
**Isolation** - параллельные транзакции не должны оказывать влияние друг на друга\
**Durability** - после завершения транзакции данные не могут быть отменены (исчезнуть)

**Transactions models:**\
**LOCAL** - JDBC\
**PROGRAMMATIC** - JPA\
**DECLARATIVE** - Spring

---

**Propagation:**\
**REQUIRED** - если нет активной транзакции, спринг создаст новую, если уже есть - присоединится к текущей трансакции\
**SUPPORT** - если нет активной трансакции, спринг выполнит действие вне транзакции, если есть - присоединится\
**MANDATORY** - если нет активной трансакции, спринг бросит исключение, если есть - присоединится\
**NEVER** - если нет транзакции, выполнится без транзакции, если есть - бросит исключение\
**NOT_SUPPORTED** - если есть транзакция, спринг ее остановит, а потом выполнит вне транзакции\
**REQUIRES_NEW** - если есть трансакция, спринг ее остановит, а потом откроит новую и выполнит код в ней.\
**NESTED** - если транзакция есть, создает сейв-поинт, если нет работает как required

---

**Transaction problem:**\
**DIRTY_READ** - чтение данных, добавленных или изменённых транзакцией, которая впоследствии откатится.\
**NON_REPEATABLE READ** - при повторном чтении в рамках 1 транзакции ранее прочитанные данные оказываются изменёнными.\
**PHANTOM_READ** - при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк.

---

**Transaction isolation level:**\
**READ_UNCOMMITTED** - (нет защиты) другие транзакции **могут** читать не закоммиченные данные, измененные текущей транзакцией.\
**READ_COMMITTED** - (защита от **DIRTY READ**) другие транзакции **не могут** читать не закоммиченные данные, измененные текущей транзакцией.\
**REPEATABLE_READ** - (защита от **NON REPEATABLE READ**) **Read committed** + другие транзакции **НЕ могут** изменять данные читаемые текущей транзакцией до ее завершения.\
**SERIALIZABLE** - (защита от **PHANTOM READ**) **Repeatable read** + другие транзакции **НЕ могут** вставлять новые данные со значениями ключа которые входят в диапазон ключей для считываемых инструкциями текущей транзакции до ее завершения.

---

**Hibernate**\
ORM фремворк предназначен для решения задач объектно-реляционного отображения, самая популярная реализация спецификации JPA

**Интерфейсы Hibernate:**

**SessionFactory** неизменяемый потокобезопасный объект с компилированным маппингом для одной базы данных.\
Необходимо инициализировать **SessionFactory** всего один раз. Используется для получения объектов **Session**, которые используются для операций с базами данных.

**Session** однопоточный короткоживущий объект, который предоставляет связь между объектами приложения и базой данных.\
оборачивает **JDBC Connection** и работает как фабрика для **Transaction**.\
Разработчик должен открывать сессию по необходимости и закрывать ее сразу после использования.\
Экземпляр **Session** является интерфейсом между кодом в **java** приложении и **hibernate** и предоставляет методы для операций **CRUD**.

**Transaction** однопоточный короткоживущий объект, используемый для атомарных операций.

---

**Аннотации Hibernate:**\
**@Entity** - используется для указания класса как **entity bean**.\
**@MappedSuperclass** - когда мы хотим спрятать общие поля нескольких entity. **MappedSuperclass** не рассматривается как отдельная сущность в бд.\
**@Table** -  используется для определения имени таблицы из БД, которая будет отображаться на **entity bean**.\
**@Column** - определяет имя колонки из таблицы в базе данных.\
**@Id** - определяет primary key в **entity bean**.\
**@GeneratedValue** - задает стратегию создания primary key.
- **AUTO** - (default) на основе типа поля в **id** будет генерировать **Numeric** или **UUID** значения
- **IDENTITY** - полагается на **IdentityGenerator** в бд колонка **identity** (автоинкрементирует)
- **SEQUENCE** - (recommended) полагается на **SequenceStyleGenerator** генерирует инкрементные integers при каждом последующем запросе.
- **TABLE** - hibernate эмулирует **sequence** через дополнительную таблицу.

**@OneToOne** - задает связь один-к-одному между двумя сущностными бинами.\
если мы хотим связать 2 сущности, 1 отвечает за аутентиикацию пользователя, 2 содержит информацию не относящуюся к аутентификации\
**@OneToMany** - связь один ко многим (автор может иметь много книг). (mappedBy = "author") указывается колонка, по которой маппятся книги.\
**@ManyToOne** - связь многие к одному (книга может иметь только одного автора).\
**@JoinColumn** - указывается в отношении **ManyToOne** с указанием поля внешнего ключа (например id автора книги).\
**@ManyToMany** - связь многие ко многим (книга может иметь многих авторов и автор может иметь много книг).\
**@JoinTable** - маппинг **ManyToMany** происходит через отдельную таблицу.\
(параметр **name**-имя таблицы, **joinColumns**-id в 1 таблице, **inverseJoinColumns**-id в таблице 2).

**@Temporal** - (DATE, TIME, TIMESTAMP) маппит java тип даты/времени в тип поддерживаемый бд. (Calendar.class не маппится в бд.TIME)\
**@Enumerated** - (ORDINAL, STRING) используется для сопоставления значения enum в бд **Ordinal** номер знач в enum, **String** строкой.\
**@Converter** - заменяет **@Enumerated** нужен доп сервис импл. AttributeConverter. решает проблему изменения enum.\
**@EmbeddedId** - используется для определения составного ключа в бине.\
**@Embeddable** - (field annotation) для отображения **композиции** в общую таблицу.\
**@Embedded** - (class annotation) для отображения **композиции** в общую таблицу.\
**@AttributeOverride** - определяет приоритетное поле в случае **Embeded**.\
**@Cascade** - определяет каскадную связь между двумя **entity бинами**.

---

**Cостояния entity bean:**
- **Transient** - объект никогда не был связан с сессией и не является persistent.\
Объект в этом состоянии может стать **persistent** при вызове метода **save(), persist()** или **saveOrUpdate()**.\
Объект **persistent** может перейти в **transient** состоянии после вызова метода **delete()**.
- **Persistent** - persisted сущность всегда имеет id. persistent объект связан с уникальной сессией. Любой экземпляр, возвращаемый методами **get()** или **load()** находится в состоянии **persistent**.
- **Detached** - объект был персистентным, но сейчас не связан с какой-либо сессией, то он находится detached состоянии.\
такой объект можно сделать персистентным используя методы **update(), saveOrUpdate(), lock()** или **replicate()**.\
Состояния **transient** или **detached** так же могут перейти в состояние **persistent** как новый объект персистентности после вызова метода **merge()**.

---

**Методы Hibernate:**
- **save()** используется для сохранения сущности в базу данных. Может быть вызван без транзакции. Немедленно возвращает сгенерированный идентификатор.
- **persist()** аналогичен save() с транзакцией. Возвращает сгенерированный идентификатор после TR.commit.
- **saveOrUpdate()** использует запрос для вставки или обновления. Если данные уже есть в бд, то будет обновление. Может быть вызван без транзакции.
- **flush()** смывает накопившиеся **inserts, updates** и **deletes** в бд. По-умолчанию **flush** выполняется в случаях:
  - Перед выполнением query (чтобы соблюсти принцип ACID)\ 
  - При коммите транзакции\
  - При persist новой сущности - в случае когда мы можем получить ее **id** только через **insert**.

---

**Collection Hibernate:**\
коллекции используются для представления связи one-to-many.
- **Set** - неупорядоченное множество сущностей без повторений.
- **Bag** - неупорядоченное множество сущностей. java нет такой структуры => любой list без указания колонки сортирования = bug.
- **List** - упорядоченное множество сущностей.

---

**Criteria API:**
используется для выборки из базы данных в более объектно-ориентированном стиле.

---

**N+1 проблема**\
это ситуация, когда вместо одного запроса на выбор **N** книг происходит по меньшей мере **N+1** запрос.\
способ решения **N+1** проблемы это сделать **fetch** связанных таблиц. однако у нас может возникнуть несколько других проблем:\
- Пагинация в случае отношений **OneToMany hibernate** не сможет указать **offset** и **limit**. Поэтому пагинация будет происходить **in-memory**.\
- Проблема декартова произведения - это ситуация, когда на выбор **N** книг с **M** главами и **K** авторами бд возвращает N * M * K строк.