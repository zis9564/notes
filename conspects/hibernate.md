**Hibernate**\
ORM фремворк предназначен для решения задач объектно-реляционного отображения.

**Интерфейсы Hibernate:**

**SessionFactory** неизменяемый потокобезопасный объект с компилированным маппингом для одной базы данных.\
Необходимо инициализировать **SessionFactory** всего один раз.\
Используется для получения объектов **Session**.

**Session** однопоточный короткоживущий объект, предоставляет связь между объектами приложения и бд.\
**Session** предоставляет методы для **CRUD** операций.\
Оборачивает **JDBC Connection** и работает как фабрика для **Transaction**.\
Разработчик должен открывать сессию по необходимости и закрывать ее сразу после использования.\

**Transaction** однопоточный короткоживущий объект, используемый для атомарных операций.

---

**Аннотации Hibernate:**\
**@Entity** - используется для указания класса как **entity bean**.\
**@MappedSuperclass** - когда мы хотим спрятать общие поля нескольких entity. **MappedSuperclass** не рассматривается как отдельная сущность в бд.\
**@Table** -  используется для определения имени таблицы из БД, которая будет отображаться на **entity bean**.\
**@Column** - определяет имя колонки из таблицы в базе данных.\
**@Id** - определяет primary key в **entity bean**.\
**@GeneratedValue** - задает стратегию создания primary key.
- **AUTO** - (default) на основе типа поля в **id** будет генерировать **Numeric** или **UUID** значения
- **IDENTITY** - полагается на **IdentityGenerator** в бд колонка **identity** (автоинкрементирует)
- **SEQUENCE** - (recommended) полагается на **SequenceStyleGenerator** генерирует инкрементные integers при каждом последующем запросе.
- **TABLE** - hibernate эмулирует **sequence** через дополнительную таблицу.

**@OneToOne** - задает связь один-к-одному между двумя сущностными бинами.\
если мы хотим связать 2 сущности, 1 отвечает за аутентиикацию пользователя, 2 содержит информацию не относящуюся к аутентификации\
**@OneToMany** - связь один ко многим (автор может иметь много книг). (mappedBy = "author") указывается колонка, по которой маппятся книги.\
**@ManyToOne** - связь многие к одному (книга может иметь только одного автора).\
**@JoinColumn** - указывается в отношении **ManyToOne** с указанием поля внешнего ключа (например id автора книги).\
**@ManyToMany** - связь многие ко многим (книга может иметь многих авторов и автор может иметь много книг).\
**@JoinTable** - маппинг **ManyToMany** происходит через отдельную таблицу.\
(параметр **name**-имя таблицы, **joinColumns**-id в 1 таблице, **inverseJoinColumns**-id в таблице 2).

**@Temporal** - (DATE, TIME, TIMESTAMP) маппит java тип даты/времени в тип поддерживаемый бд. (Calendar.class не маппится в бд.TIME)\
**@Enumerated** - (ORDINAL, STRING) используется для сопоставления значения enum в бд **Ordinal** номер знач в enum, **String** строкой.\
**@Converter** - заменяет **@Enumerated** нужен доп сервис импл. AttributeConverter. решает проблему изменения enum.\
**@EmbeddedId** - используется для определения составного ключа в бине.\
**@Embeddable** - (field annotation) для отображения **композиции** в общую таблицу.\
**@Embedded** - (class annotation) для отображения **композиции** в общую таблицу.\
**@AttributeOverride** - определяет приоритетное поле в случае **Embeded**.\
**@Cascade** - определяет каскадную связь между двумя **entity бинами**.

---

**Cостояния entity bean:**
- **Transient** - объект никогда не был связан с сессией и не является persistent.\
из **transient** в **persistent** entity переходит при вызове метода **save(), persist()** или **saveOrUpdate()**.\
из **persistent** в **transient** может перейти после вызова метода **delete()**.
- **Persistent** - сущность всегда имеет id. persistent объект связан с уникальной сессией. Любой entity, возвращаемый **get()** или **load()** = **persistent**.
- **Detached** - объект был persistent, но сейчас не связан с какой-либо сессией, то он находится detached состоянии.\
из **detached** в **persistent** можно используя методы **update(), saveOrUpdate()**.\
**transient** или **detached** entity могут перейти в **persistent** как новый объект после вызова метода **merge()**.

---

**Методы Hibernate:**
- **save()** сохраняет entity в бд. генерирует id перед сохранением в бд. не соответствует JPA специикации.
  - вызов save() на **persisted** entity, не будет иметь эффекта, но каскадно обновит зависимые entity.
  - вызов save() на **detached** entity создает новую сущность и сохраняет в бд, что ведет к дубликации записи.
- **persist()** аналогичен save() но не возвращает id. 
  - вызов persist() на **persisted** entity, не будет иметь эффекта, но каскадно обновит зависимые entity.
  - вызов persist() на **detached** entity, вызовет exception. 
- **update()** похож на save(), но возвращает void.
  - вызов update() на **transient** entity, вызовет исключение.
- **saveOrUpdate()** использует запрос для вставки или обновления. Если данные уже есть в бд, то будет обновление.
  - в отличие от update() не вызовет исключения на **transient** entity.
- **get()** вернет **persisted** entity по id или null.
- **load()** вернет **persisted** entity по id или бросит исклчение.
- **merge()** обновляет **persisted** entity новыми значениями из экземпляра **detached** entity. вернет обновленный entity.
- **flush()** смывает накопившиеся **inserts, updates** и **deletes** в бд. По-умолчанию **flush** выполняется в случаях:
  - Перед выполнением query (чтобы соблюсти принцип ACID)\
  - При коммите транзакции
  - При persist новой сущности - в случае когда мы можем получить ее **id** только через **insert**.

---

**Collection Hibernate:**\
коллекции используются для представления связи one-to-many.
- **Set** - неупорядоченное множество сущностей без повторений.
- **Bag** - неупорядоченное множество сущностей. java нет такой структуры => любой list без указания колонки сортирования = bug.
- **List** - упорядоченное множество сущностей.

---

**Criteria API:**\
deprecated в Hibernate с 5.2 поэтому рекомендуется использовать **JPA Criteria API**\
**Criteria API** помогает создавать объект запроса **Criteria**, применяя к нему различные фильтры и логические условия, не используя при этом SQL.\
**Criteria** в отличие от **HQL** и **SQL** объектно-ориентирована и легко читаема, также позволяет обнаружить ошибки на этапе компиляции.

---

**N+1 проблема**\
это ситуация, при которой выполняется N дополнительных SQL-запросов для получения тех же данных, которые можно получить при выполнении одного SQL-запроса.\
Чтобы избежать этой проблемы, нужно использовать **JoinType.LAZY** и **JOIN/FETCH** в запросах Criteria, HQL, SQL, JPQL.\
Другими словами там, где появляется эта проблема, нужно самим ручками писать запросы. 

---

**Кеш в Hibernate**\
**кеш 1 уровня** привязан к объекту **Session** и его нельзя отключить.

**кеш 2 уровня** привязан к объекту **Session Factory** по умолчанию он отключен. Его можно включить и настроить что именно кешировать.\
чтение из кеша 2 уровня происходит только в случае, если объект не был найден в кеше 1 уровня.\
Hibernate хранит в кеше не объекты классов, а информацию в виде массивов строк, чисел и т. д.\
Идентификатор объекта является указателем на эту информацию. Это своего рода Map, где **ключ - id** , а **массивы данных - значение**.

**Стратегии кеширования 2 уровня:**
- Read-only
- Read-write
- Nonstrict-read-write
- Transactional

**Проблемы кеша 2 уровня**\
1 при миграции бд на работающем сервере, возникает проблема несовместимости данны, тк SessionFactory о миграции ничего не знает.\
2 объекты и их зависимости кешируются отдельно. При удалении объекта из кеша, или каскадное удаление зависимостей вызывают неконсистентность данных.

---

**TRANSACTION:**\
это последовательность операций над данными имеющая начало и конец. Транзакция должна соответствовать требованиям ACID.\
**Atomicity** - выполнена полностью или не выполнена совсем\
**Consistency** - фиксирует результаты сохраняя консистентность бд\
**Isolation** - параллельные транзакции не должны оказывать влияние друг на друга\
**Durability** - после завершения транзакции данные не могут быть отменены (исчезнуть)

**Transactions models:**\
**LOCAL** - JDBC\
**PROGRAMMATIC** - JPA\
**DECLARATIVE** - Spring

---

**Propagation:**\
**REQUIRED** - если нет активной транзакции, спринг создаст новую, если уже есть - присоединится к текущей трансакции\
**SUPPORT** - если нет активной трансакции, спринг выполнит действие вне транзакции, если есть - присоединится\
**MANDATORY** - если нет активной трансакции, спринг бросит исключение, если есть - присоединится\
**NEVER** - если нет транзакции, выполнится без транзакции, если есть - бросит исключение\
**NOT_SUPPORTED** - если есть транзакция, спринг ее остановит, а потом выполнит вне транзакции\
**REQUIRES_NEW** - если есть трансакция, спринг ее остановит, а потом откроит новую и выполнит код в ней.\
**NESTED** - если транзакция есть, создает сейв-поинт, если нет работает как required

---

**Transaction problem:**\
**DIRTY_READ** - чтение данных, добавленных или изменённых транзакцией, которая впоследствии откатится.\
**NON_REPEATABLE READ** - при повторном чтении в рамках 1 транзакции ранее прочитанные данные оказываются изменёнными.\
**PHANTOM_READ** - при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк.

---

**Transaction isolation level:**\
**READ_UNCOMMITTED** - (нет защиты) другие транзакции **могут** читать не закоммиченные данные, измененные текущей транзакцией.\
**READ_COMMITTED** - (защита от **DIRTY READ**) другие транзакции **не могут** читать не закоммиченные данные, измененные текущей транзакцией.\
**REPEATABLE_READ** - (защита от **NON REPEATABLE READ**) **Read committed** + другие транзакции **НЕ могут** изменять данные читаемые текущей транзакцией до ее завершения.\
**SERIALIZABLE** - (защита от **PHANTOM READ**) **Repeatable read** + другие транзакции **НЕ могут** вставлять новые данные со значениями ключа которые входят в диапазон ключей для считываемых инструкциями текущей транзакции до ее завершения.

---

**Нормальные формы баз данных:**\
всего существует 5 оновных нормальных форм баз данных, но ипользуют обычно не выше 3.\
Нормализация избавляет нас от избыточности, а значит повышает эффективность
1. нет дублирующих строк в таблице, в каждой ячейке хранится атомарное значение, столбцец хранит данные одного типа.
2. требования 1 нормальной формы, таблица должна иметь ключ, все неключевые столбцы зависят от ключа.
3. требования 2 нормальной формы, в таблицах отсутствует транзитивная зависимость.

**Транзитивная зависимость** - это когда неключевые столбцы зависят от значений других неключевых столбцов.