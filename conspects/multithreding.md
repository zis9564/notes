
###### Концепция многопоточности
- **атомарность** - операция выполняется полностью или не выполняется совсем.
- **видимоть** - Условия, при которых один поток видит изменения, сделанные другим потоком.
---

###### Проблемы многопоточности
- **visibility problem** - это проблема видимости локальных переменных. когда один поток изменяет переменную, и даже обновляет значение в heap второй поток может эти изменения не подтянуть. Чтобы исправить эту проблему существует ключевое слово volatile
- **racing condition** - когда один и тот же ресурс используется несколькими потоками одновременно и в зависимости от порядка действий каждого потока может быть несколько возможных результатов.
- **Deadlock** - взаимная блокировка когда несколько потоков и каждый ожидает ресурс, принадлежащий другому потоку.\
**решение** -> использовать блок с timeout.
- **Livelock** - потоки тратят все свое время на переговоры о доступе к ресурсу.\
**решение** -> избегать блокировку ресурсов в течение длительных периодов.
---

###### Happens before
**Happens before** отношение имеет cледующие свойства:
- Вызов **Thread start** происходит до любого действия в этом потоке.
- Возврат монитора происходит до любого последующего захвата этого же монитора.
- Запись в **volatile-переменную** происходит до любого последующего считывания переменной.
- Запись в **final-переменную** происходит до публикации ссылки объекта.
- Все действия в потоке выполняются до возвращения из **Thread join** в этом потоке.
---

###### Synchronized
- **Synchronized** - блокирует доступ других потоков к переменной, гарантирует что после завершения блока, все изменения входящие в блок будут залиты в **main memory**. со стороны чтения, обновление переменных происходит перед входом в блок synchronized и никакие изменения в переменных после открытия блока synchronized на чтение, не будут учтены в вычислениях
- **Synchronized** объект указывает на **this**
- **Synchronized** класс указывает на **class**
- **AtomicInteger** используется для поддержки счетчиков.
- **Vilotile** используется для **boolean** переменных. используется для решения проблемы видимости, Изменение будет обновлено сразу в **main memory**.
- **Callable/Runnable** это интерейсы, которые имплементируются в классе, где предполагается логика выполняемая **Thread**.
- **Callable** это более продвинутая штука чем **Runnable**, тк может обрабатывать ошибки и возвращать **Future**
- **Future** это абстракция для асинхронного вычисления. Представляет результат вычисления, который может быть доступен в какой-либо момент: либо вычисленное значение, либо исключение. Большинство методов **ExecutorService** используют **Future** как возвращаемый тип. Он предоставляет методы для изучения текущего состояния **future** или блокирует до тех пор, пока не будет доступен результат.
- **CompletableFuture** это абстракция для произведения асинхронных вычислений. В отличие от **Future**, рекомендуется регистрировать обратные вызовы для создания конвейера задач, которые должны выполняться, когда доступен результат или исключение.
---

###### Состояние мониторов:
**wait/notify/notifyAll** методы класса **Object**\
**wait** - заставляет поток заснуть\
**notify** - вызывается другим потоком чтобы пробудить произвольный ждущий поток.\
**notifyAll** - вызывается другим потоком, чтобы пробудить все спящие потоки\
**Thread.interrupt** - вызов бросает **InterruptedException**.

###### Обработка InterruptedException:
- очистить все ресурсы и завершить выполнение потока.
- объявить что метод бросает InterruptedException.
---

###### Пулы потоков:
- **newSingleThreadExecutor** - Возвращает ExecutorService только с одним потоком.
- **newFixedThreadPool** - Возвращает ExecutorService с фиксированным количеством потоков.
- **newCachedThreadPool** - Возвращает ExecutorService с пулом потоков различного размера.
- **newSingleThreadScheduledExecutor** - Возвращает ScheduledExecutorService с одним потоком.
- **newScheduledThreadPool** - Возвращает ScheduledExecutorService с основным набором потоков.
- **newWorkStealingPool** - Возвращает крадущий задачи ExecutorService.
- **scheduledPool** - позволяет выполнять запланированные задаи
- **ForkJoinPool** - потоки пытаются найти и запустить поставленные задачи, либо задачи, созданные другими активными потоками.\
Задачи отправляются с помощью методов **submit, invokeAll, invokeAny**
---

###### Потокобезопасные коллекции:
- **ConcurrentHashMap** - обеспечивает параллельный доступ
  чтение не блокирует и отражают результаты последней завершенной записи.
  запись требует блокировки.
- **ConcurrentSkipListMap** - обеспечивает параллельный доступ + сортировку подобной **TreeMap**.
  чтение не блокирует и отражает результаты последней завершенной записи. Запись требует блокировки.