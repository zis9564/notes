**Концепция Spring:**\
Основной концепт - это инверсия контроля.\
Вместо того чтобы самим создавать экземпляры классов и управлять их завиимостями, Spring берет эту работу на себя.\
Spring реализует инверсию контроля используя **dependency injection**.\
**IoC Container** он же **Context** хранит конигурацию нашего приложения и бины.

---

Сконфигурировать **Spring Context** можно с помощью **XML** или **Annotation**:
- создать класс и аннотировать его **@Configuration**
- создать метод и аннотировать его **@Bean**
- этот метод-фабрика должен возвращать экземпляр класса, который мы хотим получить. Экземпляр класса, который мы получаем таким образом, называется **bean**, он теперь находятся под управлением **Spring**.
- создавая бины таким образом, мы можем например управлять их **scope** используя аннотацию **@Scope**
- но нам не обязательно вручную создавать кажды bean таким образом, аннотация **@ComponentScan** скажет Spring сканировать все классы в текущей **dir** и **subDir** на наличие классов аннотированных **@Component** или аналогами.
- нам даже **@ComponentScan** не нужна, вместо этого достаточно поставить аннотацию **@SpringBootApplication** над классом Main.\
  Эта аннотация объединяет в себе:
  - **@EnableAutoConfiguration** - включает механизм автоконфигурации Spring на основе зависимостей и jar
  - **@ComponentScan**
  - **@Configuration**

---

**Bean-scope:**\
**Singleton** - определяет только один бин для каждого контейнера спринг\
**Prototype** - когда кому-то нужна ссылка на компонент, Spring создает новый бин.\
**Request** - создается по одному бину на каждый http запрос пользователя\
**Session** - создается по одному бину на каждую http сессию пользователя\
**Global-session** - создается по одному бину на каждую глобальную http сессию (используется для Portlet приложений).

---

**Жизненны цикл бина:**\
жизненным циклом бина управляет Spring context.
- Поднятие Context
- Создание объекта. (работа конструктора его класса)
- Внедрение зависимостей
- Преинициализация
- Инициализация вызов метода **@PostConstruct**
- Постинициализация
- Использование бина
- Завершение использования бина вызов **@PreDestroy**, вызов **destroy()** метода

| аннотация                        | описание                                                                                          |
|:---------------------------------|:--------------------------------------------------------------------------------------------------|
| **@ComponentScan**               | сканировать классы в текущей **dir** на наличие классов с **@Component** или аналогами.           |
| **@EnableAutoConfiguration**     | включает механизм автоконфигурации Spring на основе зависимостей и jar.                           |
| **@SpringBootApplication**       | объединяет в себе **@ComponentScan** и **@EnableAutoConfiguration**                               |
| **@Component**                   | маркер для любого компонента фреймворка.                                                          |
| **@Bean**                        | (same Component) но может быть использована на методе.                                            |
| **@Scope**                       | установка цикла жизни бина (**Singleton, Prototype, Request, Session, Global-session**)           |
| **@Service**                     | (same Component) Позволяет разработчикам понять что класс содержит бизнес-логику.                 |
| **@Repository**                  | (same Component). перехватывает исключения от бд и бросает **unchecked exception**.               |
| **@Controller**                  | класс контроллер - компонент, работающий с **HttpServletRequest** и **HttpServletResponse**       |
| **@RestController**              | объединяет 2 аннотации **@Controller** и **@ResponseBody** используется вместо **@Controller**    |
| **@ResponseBody**                | маркер обозначает что метод может возвращать кастомный объект в виде **xml, json**...             |
| **@EnableTransactionManagement** | дает возможность использовать **@Transaction**, SpringBoot автоматически ее включит за нас.       |
| **@Transactional**               | выполняет логику метода в рамках транзакции                                                       |
| **@Autowired**                   | установливает значение поля. не нужна если есть **@SpringBootApplication** или **@ComponentScan** |
| **@RequestMapping**              | используется для маппинга url запроса на указанный метод или класс.                               |
| **@PathVariable**                | показывает, что параметр метода должен быть связан с переменной из url.                           |
| **@PostConstruct**               | метод будет вызван после вызова конструктора бина.                                                |
| **@PreDestroy**                  | метод будет вызван перед уничтожением бина.                                                       |
| **@Profile**                     | создание профилей конфигурации проекта. Применяется к бинам и к конфигурационным классам.         |
| **@Value**                       | внедряет значения свойств в бины.                                                                 |

---

**Transaction**\
Встретив **@Transactional** в bean компоненте, Spring создаст proxy-server для компонента.\
Этот proxy имеет доступ к **TransactionManager** и будет запрашивать открытие/закрытие транзакции и сессии.\
Используя JDBC мы сами обращались к **TransactionManager**, теперь Spring делает это за нас.

**@Transactional** работает только с **public** методами, в противном случае метод выполнится вне транзакции не выбросив исключения. потому что **proxy** не видит этих методов.

**ситуация 1:**\
**Class А method1( method2() )**, оба метода **@Transactional**\
логическая транзакция будет одна, так как задействован всего 1 прокси.

**ситуация 2:**\
**Class А method( Class B.method() )** оба метода **@Transactional**\
c точки зрения бд, это должна быть 1 **физическая** транзакция, но в Spring это будет 2 логические транзакции.\
Spring объеденит эти 2 логические транзакции в 1 физическую, если **Propagation** = **REQUIRED**.\
но если **B.method()** = **REQUIRES_NEW**, то в бд будет 2 физические транзакции.

---

**Propagation:**\
**REQUIRED** - если нет активной транзакции, спринг создаст новую, если уже есть - присоединится к текущей трансакции\
**SUPPORT** - если нет активной трансакции, спринг выполнит действие вне транзакции, если есть - присоединится\
**MANDATORY** - если нет активной трансакции, спринг бросит исключение, если есть - присоединится\
**NEVER** - если нет транзакции, выполнится без транзакции, если есть - бросит исключение\
**NOT_SUPPORTED** - если есть транзакция, спринг ее остановит, а потом выполнит вне транзакции\
**REQUIRES_NEW** - если есть трансакция, спринг ее остановит, а потом откроит новую и выполнит код в ней.\
**NESTED** - если транзакция есть, создает сейв-поинт, если нет работает как required

---

**Transaction problem:**\
**DIRTY_READ** - чтение данных, добавленных или изменённых транзакцией, которая впоследствии откатится.\
**NON_REPEATABLE READ** - при повторном чтении в рамках 1 транзакции ранее прочитанные данные оказываются изменёнными.\
**PHANTOM_READ** - при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк.

---

**Transaction isolation level:**\
**READ_UNCOMMITTED** - (нет защиты) другие транзакции **могут** читать не закоммиченные данные, измененные текущей транзакцией.\
**READ_COMMITTED** - (защита от **DIRTY READ**) другие транзакции **не могут** читать не закоммиченные данные, измененные текущей транзакцией.\
**REPEATABLE_READ** - (защита от **NON REPEATABLE READ**) **Read committed** + другие транзакции **НЕ могут** изменять данные читаемые текущей транзакцией до ее завершения.\
**SERIALIZABLE** - (защита от **PHANTOM READ**) **Repeatable read** + другие транзакции **НЕ могут** вставлять новые данные со значениями ключа которые входят в диапазон ключей для считываемых инструкциями текущей транзакции до ее завершения.

---