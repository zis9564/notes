**Концепция Spring:**\
Основной концепт - это инверсия контроля.\
Вместо того чтобы самим создавать экземпляры классов и управлять их завиимостями, Spring берет эту работу на себя.\
Spring реализует инверсию контроля используя **dependency injection**.\
**IoC Container** = **Context** - контекст хранит конигурацию нашего приложения и бины.\

---

Сконфигурировать **Spring Context** можно с помощью **XML** или **Annotation**:
- создать класс и аннотировать его **@Configuration**
- создать метод и аннотировать его **@Bean**
- этот метод-фабрика должен возвращать экземпляр класса, который мы хотим получить. Экземпляр класса, который мы получаем таким образом, называется **bean**, он теперь находятся под управлением **Spring**.
- создавая бины таким образом, мы можем например управлять их **scope** используя аннотацию **@Scope**
- но нам не обязательно вручную создавать кажды bean таким образом, аннотация **@ComponentScan** скажет Spring сканировать все классы в текущей **dir** и **subDir** на наличие классов аннотированных **@Component** или аналогами.
- нам даже **@ComponentScan** не нужна, вместо этого достаточно поставить аннотацию **@SpringBootApplication** над классом Main.\
  Эта аннотация объединяет в себе:
  - **@EnableAutoConfiguration** - включает механизм автоконфигурации Spring на основе зависимостей и jar
  - **@ComponentScan**
  - **@Configuration**

---

**Bean-scope:**\
**Singleton** - определяет только один бин для каждого контейнера спринг\
**Prototype** - когда кому-то нужна ссылка на компонент, Spring создает новый бин.\
**Request** - создается по одному бину на каждый http запрос пользователя\
**Session** - создается по одному бину на каждую http сессию пользователя\
**Global-session** - создается по одному бину на каждую глобальную http сессию (используется для Portlet приложений).

---

| аннотация                        | описание                                                                                                                                |
|:---------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------|
| **@ComponentScan**               | сканировать классы в текущей **dir** на наличие классов с **@Component** или аналогами.                                                 |
| **@EnableAutoConfiguration**     | включает механизм автоконфигурации Spring на основе зависимостей и jar.                                                                 |
| **@SpringBootApplication**       | объединяет в себе **@ComponentScan** и **@EnableAutoConfiguration**                                                                     |
| **@Component**                   | маркер для любого компонента фреймворка.                                                                                                |
| **@Bean**                        | (same Component) но может быть использована на методе.                                                                                  |
| **@Scope**                       | установка цикла жизни бина (**Singleton, Prototype, Request, Session, Global-session**)                                                 |
| **@Service**                     | (same Component) Позволяет разработчикам понять что класс содержит бизнес-логику.                                                       |
| **@Repository**                  | (same Component) класс-репозиторий. перехватывает исключения от бд и бросает **unchecked exception**.                                   |
| **@Controller**                  | класс контроллер - компонент, работающий с **HttpServletRequest** и **HttpServletResponse**                                             |
| **@RestController**              | объединяет 2 аннотации **@Controller** и **@ResponseBody** используется вместо устаревшей **@Controller**                               |
| **@ResponseBody**                | маркер обозначает что метод может возвращать кастомный объект в виде **xml, json**...                                                   |
| **@EnableTransactionManagement** | дает возможность использовать **@Transaction**, SpringBoot автоматически ее включит за нас.                                             |
| **@Transactional**               | перед исполнением метода начинается транзакция, после выполнения транзакция коммитится, при Exception откатывается.                     |
| **@Autowired**                   | автоматически установливает значение поля. Если используется **@SpringBootApplication** или **@ComponentScan**, эта аннотация не нужна. |
| **@RequestMapping**              | используется для маппинга url запроса на указанный метод или класс.                                                                     |
| **@PathVariable**                | показывает, что параметр метода должен быть связан с переменной из url.                                                                 |
| **@PostConstruct**               | метод будет вызван после вызова конструктора бина.                                                                                      |
| **@PreDestroy**                  | метод будет вызван перед уничтожением бина.                                                                                             |
| **@Profile**                     | создание профилей конфигурации проекта. Может применяться как к бинам так и к конфигурационным классам.                                 |

---

**Transaction**\
Встретив **@Transactional** в bean компоненте, Spring создаст proxy-server для компонента.\
Этот proxy имеет доступ к **TransactionManager** и будет запрашивать открытие/закрытие транзакции и сессии.\
Используя JDBC мы сами обращались к **TransactionManager**, теперь Spring делает это за нас.

**@Transactional** работает только с **public** методами, в противном случае метод выполнится вне транзакции не выбросив исключения. потому что **proxy** не видит этих методов.

**ситуация 1:**\
класс (Class A) **А.method1( method2() )**, оба метода **@Transactional**\
логическая транзакция будет одна, так как задействован всего 1 прокси.\

**ситуация 2:**\
класс (Class А, В). **А.method( B.method() )** оба метода **@Transactional**\
c точки зрения бд, это должна быть 1 **физическая** транзакция, но в Spring это будет 2 логические транзакции.\
Spring объеденит эти 2 логические транзакции в 1 физическую, если **Propagation** = **REQUIRED**.
но если **B.method()** = **REQUIRES_NEW**, то в бд будет 2 физические транзакции.\

---

**Propagation:**\
**REQUIRED** - если нет активной транзакции, спринг создаст новую, если уже есть - присоединится к текущей трансакции\
**SUPPORT** - если нет активной трансакции, спринг выполнит действие вне транзакции, если есть - присоединится\
**MANDATORY** - если нет активной трансакции, спринг бросит исключение, если есть - присоединится\
**NEVER** - если нет транзакции, выполнится без транзакции, если есть - бросит исключение\
**NOT_SUPPORTED** - если есть транзакция, спринг ее остановит, а потом выполнит вне транзакции\
**REQUIRES_NEW** - если есть трансакция, спринг ее остановит, а потом откроит новую и выполнит код в ней.\
**NESTED** - если транзакция есть, создает сейв-поинт, если нет работает как required

---

**Transaction isolation level:**\
**READ_UNCOMMITTED** - (нет защиты) другие транзакции **могут** читать не закоммиченные данные, измененные текущей транзакцией.\
**READ_COMMITTED** - (защита от **DIRTY READ**) другие транзакции **не могут** читать не закоммиченные данные, измененные текущей транзакцией.\
**REPEATABLE_READ** - (защита от **NON REPEATABLE READ**) **Read committed** + другие транзакции **НЕ могут** изменять данные читаемые текущей транзакцией до ее завершения.\
**SERIALIZABLE** - (защита от **PHANTOM READ**) **Repeatable read** + другие транзакции **НЕ могут** вставлять новые данные со значениями ключа которые входят в диапазон ключей для считываемых инструкциями текущей транзакции до ее завершения.

---