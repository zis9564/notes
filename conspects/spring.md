**Концепция Spring:**\
Основной концепт - это инверсия контроля.\
Вместо того чтобы самим создавать экземпляры классов и управлять их завиимостями, Spring берет эту работу на себя.\
Spring реализует инверсию контроля используя **dependency injection**.\
**IoC Container** = **Context** - контекст хранит конигурацию нашего приложения и бины.\

---

Сконигурировать **Spring Context** можно с помощью **XML** или **Annotation**:
- создать класс и аннотировать его **@Configuration**
- создать метод и аннотировать его **@Bean**
- этот метод-фабрика должен возвращать экземпляр класса, который мы хотим получить. Экземпляр класса, который мы получаем таким образом, называется **bean**, он теперь находятся под его управлением **Spring**.
- создавая бины таким образом, мы можем например управлять их **scope** используя аннотацию **@Scope**
- но нам не обязательно вручную создавать кажды bean таким образом, аннотация **@ComponentScan** скажет Spring сканировать все классы в текущей **dir** и **subDir** на наличие классов аннотированных **@Component** или аналогами.
- нам даже **@ComponentScan** не нужна, вместо этого достаточно поставить аннотацию **@SpringBootApplication** над классом Main.\
  Эта аннотация объединяет в себе:
  - **@EnableAutoConfiguration** - включает механизм автоконфигурации Spring на основе зависимостей и jar
  - **@ComponentScan**
  - **@Configuration**

---

**Bean-scope:**\
**Singleton** - определяет только один бин для каждого контейнера спринг\
**Prototype** - когда кому-то нужна ссылка на компонент, Spring создает новый бин.\
**Request** - создается по одному бину на каждый http запрос пользователя\
**Session** - создается по одному бину на каждую http сессию пользователя\
**Global-session** - создается по одному бину на каждую глобальную http сессию (используется для Portlet приложений).

---

**Аннотации:**\
**@ComponentScan** - сканировать все классы в текущей **dir** и **subDir** на наличие классов аннотированных **@Component** или аналогами.\
**@EnableAutoConfiguration** - включает механизм автоконфигурации Spring на основе зависимостей и jar.\
**@SpringBootApplication** - объединяет в себе @ComponentScan и @EnableAutoConfiguration\
**@Component** - маркер для любого компонента фреймворка.\
**@Bean** - (same Component) но может быть использована на методе.\
**@Scope** - установка цикла жизни бина\
**@Service** - (same Component) Позволяет разработчикам понять что класс содержит бизнес-логику.\
**@Repository** - (same Component) показывает что класс является репозиторием + ее задача в том, чтобы перехватывать специфичные для persistent слоя исключения и повторно выдавать их как унифицированные **unchecked exception**.\
**@Controller** - класс контроллер. представляет собой компонент, работающий с **HttpServletRequest** и **HttpServletResponse** (редко используется)\
**@RestController** - аккумулирует поведение двух аннотаций **@Controller** и **@ResponseBody** используется вместо устаревшей **@Controller**\
**@ResponseBody** - маркер обозначает что метод может возвращать кастомный объект в виде xml, json...\
**@Transactional** - перед исполнением метода начинается транзакция, после выполнения транзакция коммитится, при Exception откатывается.\
**@Autowired** - позволяет автоматически установить значение поля. Если мы используем **@SpringBootApplication** или **@ComponentScan**, то эта аннотация не нужна.\
**@RequestMapping** - используется для маппинга url запроса на указанный метод или класс.\
**@PathVariable** - показывает, что параметр метода должен быть связан с переменной из url.\
**@PostConstruct** - метод будет вызван после вызова конструктора бина.\
**@PreDestroy** - метод будет вызван перед уничтожением бина.\
**@Profile** - создание профилей конфигурации проекта. Может применяться как к бинам так и к конфигурационным классам.

---

