JAVA CORE:

ООП:
	согласно этой концепции - программа состоит из оъектов, обменивающихся сообщениями. объекты могут хранить состояние и единственный способ изменить состояние - отправить сообщение.

	- Абстракция
	- Инкапсуляция
	- Полиморфизм
	- Наследование
	- Ассоциация Агрегация и Композиция.

	- Абстракция - скрывает complexity предотавляя только необходимую информацию ползователю, а
		также добавляет гибкости. позволяя разработчику изменять поведение абстракции.
		# пример частичной абстракции Абстрактный класс
		# пример полной абстракции Интерфейс

	- Инкапсуляция - улучшает безопасность данных путем закрытия доступа к полям объекта
		напрямую. чтобы изменение в классе не влекли за собой изменение внешнего поведения класса. мы можем использовать класс так как нам надо, не задумываясь о том что под капотом.

	- Полиморфизм - доавляет гибкости коду открывает путь к множественному наследованию.
		декларируя интерфейс, можно легко выбрать реализацию.
		# пример runtime полиорфиза @Override
		# пример compileTime полиорфиза method overloading.

	- Наследование - позволяет переиспользовать наш код и улушает его читаемоть

	- Ассоциация - обозначает связь между объектами.

	  Агрегация и Композиция являются частными случаями ассоциации.

	- Аггрегация - пример класс Б создается извне класса А и передаетя в контруктор. если класс А
		будет удален, класс Б все равно может исползоватся, если ссылка на объект сохранится.

	- Композиция - более тесная связь чем агрегация, когда объект не только является частью
		другого объекта, но и вообще не может принадлежать другому объекту наприер если объект Б создаетя в конструкторе класса А.

SOLID:
	принципы разработки программного обеспечения, следуя которым получается хороший код,
	который будет хорошо масштабироваться и поддерживаться в рабочем состоянии.

	S - Single Responsibility Principle - Каждый класс должен иметь только одну зону
		ответственности.
	O - Open closed Principle - Классы должны быть открыты для расширения, но закрыты для
		изменения.
	L - Liskov substitution Principle - Должна быть возможность вместо базового класса подставить
		любой его подтип, при этом работа программы не должна измениться.
	I - Interface Segregation Principle - Не нужно заставлять класс реализовывать интерфейс,
		который не имеет к нему отношения.
	D - Dependency Inversion Principle - Модули верхнего уровня не должны зависеть от модулей
		нижнего уровня. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

JDK - среда для разработки программ на Java, включающая в себя JRE
JRE - среда для обеспечения запуска Java программ, которая в свою очередь содержит JVM
JVM - интерпретатор кода Java программ.

МОДИФИКАТОРЫ ДОСТУПА:
	- private - 	видиость только внутри класса.
	- default - 	видимость только внутри пакета.
	- protected - 	видимость внутри пакета и в наследниках.
	- public - 		доступен всем.

FINAL:
	- final переменные не могут изменить свое значение после инициализации
	- final параметры методов не могут изменять своё значение внутри метода,
	- final поля не могут изменить свое значение после инициализации
	- final методы не могут быть переопределен в классах наследниках
	- final класс не может иметь наследников.

STATIC:
	- поля
	- методы
	- вложенные классы
	- блоки инициализации
	- import

ENUM:
	класс представляющий группу контант. используется когда набор значений известен на этапе
	компиляции. часто enum используется в switch. также enum позволяет итерироваться по всем споим значениям используя метод values(), которы возвращает лист значени enum. enum не может быть использован для создания экземпляров класса и не может наледоваться от других классов.

	Абстрактный класс - может описывать категорию разных объектов.
	Абстрактный класс обязательно содержит метод без реализации.
	Абстрактный класс нельзя инстанировать.
	Абстрактный класс позволяет определять поля, значения могут задавать классы наследники.
	Абстрактный класс может иметь методы по умолчанию как и интерфейс.
	Наследник абстрактного класса расширяет его функциональность

	Интерфейс - описывает часть функциональности объекта.
	Интерфейс может иметь поля, но они могут быть только public static final
	Интерфейс может иметь методы по умолчанию, как и абстрактный класс.
	Интерфейс может содержать статические методы.
	Интерфейс не способен сохранять состояния.
	Интерфейс это один из механизмов реализации принципа полиморфизма.
	Интерфейс может наследоваться от одного или нескольких интерфейсов.

	Абстрактный класс лучше всего использовать:
	- чтобы избежать дублирования кода реализуя несколько классов в одной категории
	- если наследующие классы имеют много общих свойств и реализуют похожие методы
	- поддерживать и дополнять абстрактный класс намного проще, чем добавлять новые методы в
		интерфейс
	Интерфейс лучше всего использовать:
	- если нужно описать логику, которую должны поддерживать не связанные между собой объекты.
	- если нужно привести к одному типу группу объектов и гарантировать схожую функциональность.
	- если нужно добавить какой-то маркер, говорящий, что классы поддерживают определённую
		логику.

ИЕРАРХИЯ ИСКЛЮЧЕНИЙ:
	основные типы исключений ERROR и EXCEPTION. оба наследуются от класса Throwble.
	ERROR - согласно спецификации Java не следует обрабатывать поскольку они связаны с
		проблемами уровня JVM.
	EXCEPTION - делятся на checked и unchecked
	- checked exception - должны обрабатываться блоком catch приер FileNotFoundException.
	- unchecked exception - обрабатывать не рекомендуется. пример RuntimeException.

	Статическое и динамическое связывание:
	- связывание это присоединение вызова метода к телу метода. если связывание происходит на этапе компиляции, то это раннее или статическое связывание. если связывание происходит на этапе runtime, то это позднее или динамическое связывание. Для всех методов Java используется именно позднее связывание, если только метод не был объявлен как finаl.

NESTED CLASS:
	- nested класс это класс определенный внутри другого класса.
	- nested класс должен создаваться только для того, чтобы обслуживать обрамляющий его класс.
	- nested класс имеет доступ ко всем полям и методам внешнего класса, но не наоборот.
	- nested класс ассоциируется не с внешним классом, а с его экземпляром.
	- Для создания объекта static nested класса объект внешнего класса не требуется.
	- Из объекта static nested класса можно обращаться к не ststic членам главного класса только
		через ссылку на экземпляр внешнего класса.
	- Обычные вложенные классы не могут содержать static членов. static inner классы - могут.
	- В объекте non-static inner класса хранится ссылка на объект внешнего класса. Внутри static
		класса доступ к экземпляру main класса осуществляется через указание Outer.this

АНОНИМНЫЙ КЛАСС:
	- это вложенный локальный класс без имени.
	- использование разрешено только в одном месте программы - месте его создания.
	- применяется для создания объекта функции например реализация интерфейса Comparator
	- применяется для создания объекта процесса например экземпляра класса Thread, Runnable

	параметры метода в Java всегда передаются только по значению. примитивы передают копию содержимого, ссылочные типы передают копию ссылки на объект.

КЛОНИРОВАНИЕ:
	метод clone() осуществляющий побитовое копирование объекта производного класса
	чтобы клонировать объект нужно:
	- переопределить метод clone() сделав его public,
	- в переопределенном методе вызвать super.clone()
	- иплементировать интерфейс Clonable
	- клонирование хорошо работает в случае если все поля объекта primitive, wrapped, immutable.
	иначе будет просто скопирована ссылка.
	АЛЬТЕРНАТИВЫ методу clone():
	- Фабричный метод - статический метод, возвращающий экземпляр своего класса.
	- Сериализация - сохранение и последующее восстановление объекта в/из потока байтов.
	- Конструктор копирования - конструктор, который принимает объект этого же класса и
		инициализирует поля создаваемого объекта значениями полей переданного.
	Поверхностное клонирование:
	- Если класс имеет только примитивные члены, будет создана новая копия объекта.
	- Если класс имеет ссылочные члены - копируются ссылки на объекты этих классов.
	Глубокое клонирование:
	- Все члены ссылочного типа в классе должны поддерживать клонирование
	- Если ссылочный класс не поддерживает клонирование, вызов метода clone() этого объекта,
		должен скопировать каждый его член со всеми атрибутами в новый объект класса
	# Наиболее безопасны способом клонирования через конструктор тк все операции происходят явно.
	# Метод clone() объявлен в классе Object, а не в интерейсе Clonable с указанием модификатора
		native, чтобы обеспечить доступ к стандартному механизму поверхностного копирования объектов.

ФУНКЦИОНАЛЬНЫЙ ИНТЕРФЕС:
	интерыейсы, которе имеют только один абстрактный метод. функциональный интерфейс может содержать сколько угодно дефолтных (реализованных в интерфейсе) методов, но только 1 абстрактный.
	аннотация @FunctionalInterface маркирует интерфейс функциональным, и защитит от добавления второго абстрактного метода в интерфейс. однако аннотация @FunctionalInterface не обязательна.
	Внутри лямбда-выражений запрещено обращаться к дефолтным методам

ПРЕДИКАТЫ (Predicates):
	принимают один аргумент, возвращают boolean. Интерфейс содержит различные методы по умолчанию, позволяющие строить сложные условия (and, or, negate).
ФУНКЦИИ (Functions):
	принимают один аргумент, возвращают некоторый результат. Интерфейс содержит различные методы по умолчанию, используется для построения цепочек вызовов (compose, andThen).
ПОСТАВЩИКИ (Suppliers):
	не принимают аргументов, предоставляют результат заданного типа.
ПОТРЕБИТЕЛИ (Consumers):
	принимают один аргумент, представляют собой операции, которые производятся над входным аргументом.
КОМПАРАТОРЫ (Comparators):
	принимают один аргумент, сравнивают входящие аргументы.

что нового в java 17?
- switch стал более читаемым
- появились records, которые позваляют сократить кол-во шаблонного кода
- появились sealed класы, которые позволяют более точно настроить расширяемоть классов