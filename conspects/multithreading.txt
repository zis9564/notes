MULTITHREADING:

концепция:
	- атомарность - операция выполняется полностью или не выполняется совсем.
	- видимоть - Условия, при которых один поток видит изменения, сделанные другим потоком.

проблемы:
	- visibility problem
	- racing condition

кажды тред имеет свой тред стек, в котором хранятся ссылки на переменные. сами переменные хранятся в хипе. хип общий для всех тредов.

разные треды могут ссылатья на один и тот же объект в хипе, но если класс N был создан в треде 1 и 2, то это будет 2 разных объекта в хипе. и ссылки в каждом тред-стеке будут разные.

VISIBILITY_PROBLEM это проблема видимости локальных переменных. когда один поток изменяет переменную, и даже обновляет значение в heap второй поток может эти изменения не подтянуть
чтобы исправить эту проблему существует ключевое слово vilotile
когда поле vilotile, изменение будет обновлено сразу в main memory и соответственно при чтении такой переменной, значение переменной будет подтянуто сразу из main memory. также если в какой-то метод изменяет значение одной vilotile переменной и одной не vilotile, оба этих значения будут записпны mail memory как vilotile. тоже касается чтения vilotile переменной: если в контексте метода оперирующего vilotile переменной, все остальные переменные в области видимости будут прочитаны из main memory однако если изменение переменной vilotile будет первой из серии изменений, другие не vilotile переменные не гарантированно попадут в main memory, но если изменение vilotile переменной идет в последнюю очередь, (после изменения не vilotile), не vilotile переменные будут обновлены

RACEING_CONDITION когда один и тот же ресурс используется несколькими потоками одновременно и в зависимости от порядка действий каждого потока может быть несколько возможных результатов.

HAPPENS_BEFORE отношение имеет ледующие свойства:
	- Вызов Thread start происходит до любого действия в этом потоке.
	- Возврат монитора происходит до любого последующего захвата этого же монитора.
	- Запись в volatile-переменную происходит до любого последующего считывания переменной.
	- Запись в final-переменную происходит до публикации ссылки объекта.
	- Все действия в потоке выполняются до возвращения из Thread join в этом потоке.

SYNCHRONIZED блокирует доступ других потоков к переменной, гарантирует что после завершения блока, все изменения входящие в блок будут залиты в main memory. со стороны чтения, обновление переменных происходит перед входом в блок syncrornized и никакие изменения в переменных после открытия блока syncrornized на чтение, не будут учтены в вычислениях
SYNCRONIZED может быть объект или класс. объект указывает на this, static указывает на class.
	ATOMIC_INTEGER используется для поддержки счетчиков.
	VILOTILE используется для BOOLEAN переменных. используется для решения проблемы видимости, Изменение будет обновлено сразу в main memory.
	CALLABLE/RUNNABLE это интерейсы, которые имплементируются в классе, где предполагается логика выполняемая Thread.
	CALLABLE это более продвинутая штука чем RUNNABLE, тк может обрабатывать ошибки и возвращать future

состояние мониторов:
	wait/notify/notifyAll методы класса Object
	wait - заставляет поток заснуть
	notify - вызывается другим потоком чтобы пробудить произвольный ждущий поток.
	notifyAll - вызывается другим потоком, чтобы пробудить все спящие потоки
	Thread.interrupt - вызов бросает InterruptedException.

обработка InterruptedException:
	- очистить все ресурсы и завершить выполнение потока.
	- объявить что метод бросает InterruptedException.

проблемы многопоточности:
	- Deadlock - взаимная блокировка когда несколько потоков и каждый ожидает ресурс, принадлежащий другому потоку.
		решение -> использовать блок с timeout.
	- Livelock - потоки тратят все свое время на переговоры о доступе к ресурсу.
		решение -> избегать блокировку ресурсов в течение длительных периодов

пулы потоков:
	- newSingleThreadExecutor - Возвращает ExecutorService только с одним потоком.
	- newFixedThreadPool - Возвращает ExecutorService с фиксированным количеством потоков.
	- newCachedThreadPool - Возвращает ExecutorService с пулом потоков различного размера.
	- newSingleThreadScheduledExecutor - Возвращает ScheduledExecutorService с одним потоком.
	- newScheduledThreadPool - Возвращает ScheduledExecutorService с основным набором потоков.
	- newWorkStealingPool - Возвращает крадущий задачи ExecutorService.
	sheduledPool - позволяет выполнять запланированные задаи
	ForkJoinPool - потоки пытаются найти и запустить поставленные задачи, либо задачи, созданные другими активными потоками.
	задачи отправляются с помощью методов submit invokeAll invokeAny

CALLABLE/RUNNABLE это интерейсы, которые имплементируются в классе, где предполагается логика выполняемая Thread.
RUNNABLE - представляет задачу без возвращаемого значения.
CALLABLE - представляет вычисление с возвращаемым значением. также может обрабатывать ошибки.

Future — это абстракция для асинхронного вычисления. Представляет результат вычисления, который может быть доступен в какой-либо момент: либо вычисленное значение, либо исключение. Большинство методов ExecutorService используют Future как возвращаемый тип. Он предоставляет методы для изучения текущего состояния future или блокирует до тех пор, пока не будет доступен результат.

CompletableFuture - абстракция для произведения асинхронных вычислений. В отличие от Future, рекомендуется регистрировать обратные вызовы для создания конвейера задач, которые должны выполняться, когда доступен результат или исключение.

ПОТОКОБЕЗОПАСНЫЕ_КОЛЛЕКЦИИ:
	- ConcurrentHashMap - обеспечивает параллельный доступ
		чтение не блокирует и отражают результаты последней завершенной записи.
		запись требует блокировки.
	- ConcurrentSkipListMap - обеспечивает параллельный доступ + сортировку подобной TreeMap.
		чтение не блокирует и отражают результаты последней завершенной записи.
		запись требует блокировки.
