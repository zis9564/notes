SQL/NoSQL:

ГАРАНТИИ SQL:
	Atomicity - выполнена полностью или не выполнена совсем
	Consistency - фиксирует результаты сохраняя консистентность бд
	Isolation - параллельные транзакции не должны оказывать влияние друг на друга
	Durability - после завершения транзакции данные не могут быть отменены (исчезнуть).

TRANSACTION PROBLEM:
	DIRTY READ - чтение данных, добавленных или изменённых транзакцией, которая впоследствии
		откатится
	NON REPETABLE READ - при повторном чтении в рамках 1 транзакции ранее прочитанные данные
		оказываются изменёнными.
	PHANTOM READ - при повторном чтении в рамках одной транзакции одна и та же выборка дает
		разные множества строк.

TRANSACTION ISOLATION LEVEL:
	READ_UNCOMMITTED - нет запретов
	READ_COMMITTED - запрет на чтение незакомиченных данных
	REPEATABLE_READ - одна запись - одна транзакция
	SERIALIZABLE - полная изоляция от всевозможных сайд-эффектов

ГАРАНТИИ NoSQL:
	At-most-once delivery - сообщение доставлено 1 раз или не доставлено ни разу
	At-least-once delivery - сообщение доставлено минимум 1 раз или больше
	Exactly-once delivery - сообщение гарантировано доставлено 1 раз
	если во время процесса доставки сообщеения consumer сдох, мы хотим чтобы сообщение было получено новым здоровым консюмером. Нам интересно как минимум At-least-once delivery.

	хотя никто кроме Kafka не может гарантировать Exctly-once delivery, мы можем строить нашу логику таким образом, что повторное получение сообщения не окажет вреда, однако не все операции могут быть идемпотентны.

ЦЕПОЧКА_ОТВЕТСТВЕННОСТИ:
	продюссер не может знать что его ообщения используются для этого есть концепция цепочки ответственности, которая начинается с издателя, затем переходит к системе обмена сообщениями и далее к потребителю. Каждый должен вести себя правильно, когда наступает его очередь нести ответственность за сообщение и при передаче ответственности.

ГАРАНТИЯ_УПОРЯДОЧЕННОСТИ:
	RabbitMQ и Kafka имеют FIFO гарантии. RabbitMQ гарантирует FIFO на уровне queue, Kafka на уровне topic partition.

ПРИНЦИП_РАБОТЫ RabbitMQ:
	- Издатель отправляет сообщение определенному обменнику
	- Обменник маршрутизирует его в одну или несколько очередей
	- Очередь хранит ссылку на это сообщение. Само сообщение хранится в памяти или на диске
	- Как потребитель готов получить сообщение, сервер создает и отправляет копию сообщения
	- Потребитель получает сообщение и отправляет брокеру подтверждение
	- Брокер удаляет копию сообщения из очереди. Затем удаляет из оперативной памяти и с диска

EXCHANGE - точка обмена куда publisher отправляет сообщения.
	exchnge маршрутизирует сообщения на основе созданных связей (bindings) между ним и очередью.
	exchange это строка (ссылка на модуль, где лежит логика маршрутизации) во встроенной бд.

	- DIRECT_EXCHANGE - доставляет сообщение в определенные очереди. Сообщение публикуется в exchange с ключом маршрутизации и попадает во все очереди, которые связаны с этим обменником аналогичным ключом маршрутизации.
		# ключ маршрутизации - это строка. Поиск соответствия происходит при помощи проверки строк на эквивалентность.

	- TOPIC_EXCHANGE - дает возможность выборочной маршрутизации путем сравнения ключа маршрутизации. Но, в данном случае, ключ задается по шаблону.
		# при создании шаблона используются 0+ слов (буквы AZ и az, цифры 0-9 символы *,#).
		# шаблоны в exchnge предсталяют собой структуру tree.
		# шаблоны * быстрее #
		# topic exchnge медленнее direct exchnge

	- FANOUT_EXCHANGE - все сообщения доставляются во все очереди даже если в сообщении задан ключ маршрутизации.
		# fanout exchnge самы быстры из всех
		# все консюмеры при fnout exchnge должны уметь обрабатывать все сообщения

	- HEADERS_EXCHANGE - направляет сообщения на основе сравнения пар (key, val) свойства headers привязки и аналогичного свойства сообщения. headers представляет собой Dictionary<key, val>
		# Если добавить специальный ключ "x-match": "any", сообщение маршрутизируется при частичном совпадении key val. Поведение аналогично оператору or.
		# по умолчанию ключ "x-match": "all" , сообщение маршрутизируется при частичном совпадении key val. Поведение аналогично оператору and.

	Поведение обменников можно комбинировать при помощи связи Exchange-to-Exchange.
	Создание обменника происходит при помощи синхронного RPC запроса к серверу с параметрами:
		- название exchange
		- тип exchange
		- и другие
	Обменник должен быть создан перед публикацией сообщений иначе сообщение будет удалено.

QUEUE - структура данных на диске или в оперативной памяти, которая хранит ссылки на сообщения и
	отдает их копии потребителям.
	- autoDelete - флаг. очередь удаляет себя когда все клиенты отсоединились.
	- exclusive - флаг. разрешает подключаться только одному потребителю и удаляется если закроется канал.
	- durable - флаг. очередь сохраняет состояние и восстанавливается после перезапуска брокера
BINDING - правило, которое сообщает обменнику в какую из очередей должны попадать сообщения.

AMQP канал - это механизм позволящий мультиплексировать несколько логических потоков поверх одного соединения, что в свою очередь позволяет лучше использовать ресурсы.
	- клиент может создавать 1+ каналов для связи с брокером, для того чтобы отправлять команды.
	- команды в рамках одного канала гарантировано выполняются в последовательности отправки.
	- жизненный цикл комманды привязан к соединению. если соединение закрыто, каналы вместе с ним.